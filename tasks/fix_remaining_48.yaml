# yaml-language-server: $schema=
# Fix remaining 48 test failures - 3 root causes
#
# Current Status (verified 2026-01-24):
#   - 13 U4 GEMM accuracy failures (large numerical errors, max diff ~35)
#   - 33 stripe partition failures (Metal shader compilation errors)
#   - 1 MarlinLinear test (depends on U4 fix)
#   - 1 ONNX quantized test
#
# Root Cause Analysis:
#   1. Stripe partition: MLX concatenates utils.h with our shader, causing syntax errors
#      at kernel boundaries. Line 1122 of combined source hits "kernel void marlin_gemm_fp4"
#      inside an unclosed function from utils.h.
#   2. U4 GEMM: Dequantization produces wrong values. INT4 (S4/U4) uses different math
#      than FP4 - likely scale/zero-point application order or magic number issue.
#   3. Duplicate kernel: marlin_gemm_fp4_single_stage defined twice (lines 1044 and 2075).
#
# Testing Commands:
#   Fast batch: pytest tests/test_stripe_partition.py::TestKParallelReduction::test_k_parallel_reduction_large_k -v --tb=short
#   U4 batch:   pytest tests/test_accuracy.py::TestU4GEMMAccuracy -v --tb=short
#   Full:       pytest tests/ -v --tb=no | tail -50

tasks:
  # ==========================================================================
  # P0: STRIPE PARTITION SHADER COMPILATION (33 tests blocked)
  # ==========================================================================

  - name: fix-metal-shader-mlx-compat
    prompt: |
      Fix Metal shader compilation errors when used with MLX's mx.fast.metal_kernel().

      **Problem**: When MLX compiles marlin_gemm.metal, it concatenates its internal utils.h
      (~1100 lines) BEFORE our source. If utils.h ends with an incomplete construct (unclosed
      function/namespace), our first `kernel void` appears inside that construct, causing:

      ```
      mlx/backend/metal/kernels/utils.h:1122:1: error: expected expression
      kernel void marlin_gemm_fp4(
      ^
      ```

      **Root Cause Options**:
      1. Our shader has syntax that triggers MLX preprocessing issues
      2. A missing closing brace somewhere in our utilities
      3. Something in our #include order conflicts with MLX

      **Fix Strategy**:
      1. Read `src/marlin_gemm.metal` lines 1-100 (preamble and includes)
      2. Ensure ALL function/struct definitions are properly closed
      3. Add an explicit `// MLX compatibility marker` comment before first kernel
      4. Wrap utilities in a namespace or ensure clean function boundaries
      5. Run: `cd metal_marlin && PYTHONPATH=. uv run pytest tests/test_stripe_partition.py::TestKParallelReduction::test_k_parallel_reduction_large_k -v --tb=short`

      **Files**:
      - `src/marlin_gemm.metal` - main shader, lines 1-700 contain utilities
      - `tests/test_stripe_partition.py` - uses mx.fast.metal_kernel() to compile

      After fix, stripe partition tests should compile without MLX utils.h errors.
    priority: P0
    dependencies: []

  - name: remove-duplicate-kernel-definition
    prompt: |
      Remove duplicate `marlin_gemm_fp4_single_stage` kernel definition in marlin_gemm.metal.

      **Problem**: The kernel is defined TWICE:
      - Line 1044: First definition (correct, with FP4 dequant)
      - Line 2075: Second definition (appears to be partial/duplicate)

      **Verification**:
      ```bash
      grep -n "^kernel void marlin_gemm_fp4_single_stage" src/marlin_gemm.metal
      ```

      **Fix**:
      1. Read lines 2060-2124 of `src/marlin_gemm.metal`
      2. The second definition at line 2075 should be DELETED entirely
      3. Keep only the first definition at line 1044
      4. Ensure file still compiles: check for balanced braces

      This is part of the stripe partition compilation fix - duplicate kernel definitions
      cause Metal compiler errors.
    priority: P0
    dependencies: []

  - name: validate-shader-syntax-standalone
    prompt: |
      Validate marlin_gemm.metal can compile standalone and identify any syntax issues.

      **Task**: Create a minimal test script that compiles the shader WITHOUT MLX concatenation
      to isolate whether the issue is in our code or the MLX integration.

      **Steps**:
      1. Create `scripts/validate_shader.py`:
         ```python
         import mlx.core as mx
         from pathlib import Path
         
         src = (Path(__file__).parent.parent / "src" / "marlin_gemm.metal").read_text()
         
         # Try to compile each kernel individually
         kernels = ["marlin_gemm_fp4", "marlin_gemm_fp4_striped", "marlin_zero_reduction"]
         for name in kernels:
             try:
                 k = mx.fast.metal_kernel(name=name, input_names=["A"], output_names=["B"], source=src)
                 print(f"✓ {name}")
             except Exception as e:
                 print(f"✗ {name}: {e}")
         ```
      2. Run: `cd metal_marlin && PYTHONPATH=. uv run python scripts/validate_shader.py`
      3. If all compile, issue is test-specific. If fails, fix the reported line.

      Document findings in the script as comments.
    priority: P0
    dependencies:
      - remove-duplicate-kernel-definition

  # ==========================================================================
  # P0: U4 GEMM ACCURACY (13 tests, numerical errors)
  # ==========================================================================

  - name: debug-u4-dequant-reference
    prompt: |
      Debug U4 (INT4) dequantization mismatch between Metal kernel and Python reference.

      **Error Pattern** (from test_metal_u4_gemm_vs_reference):
      - Max abs diff: 8-35 (should be <0.01)
      - Mean abs diff: 1-5 (should be <0.001)
      - Results are "close but wrong" - suggests scale or zero-point math error

      **INT4 Dequantization Formula**:
      ```
      # Reference (Python):
      dequant = (packed_int4 - zero_point) * scale

      # Kernel (Metal, must match):
      half dequant_u4(uint nibble, half scale, half zero) {
          return (half(nibble) - zero) * scale;
      }
      ```

      **Common INT4 Bugs**:
      1. Unsigned vs signed interpretation (U4 is 0-15, S4 is -8 to +7)
      2. Zero-point subtraction BEFORE vs AFTER scale multiplication
      3. Group indexing: which elements share a scale/zero pair
      4. Packed nibble extraction order (low nibble vs high nibble first)

      **Debug Steps**:
      1. Read `src/marlin_gemm.metal` - find `marlin_gemm_fused_u4` kernel (~line 1875)
      2. Read `tests/test_accuracy.py` - find `TestU4GEMMAccuracy` class (~line 650)
      3. Compare the dequant math formula symbol-by-symbol
      4. Check nibble extraction: `(packed >> (i*4)) & 0xF` ordering
      5. Check group_size usage: Metal and Python must index scales identically

      **Validation**:
      ```bash
      cd metal_marlin && PYTHONPATH=. uv run pytest tests/test_accuracy.py::TestU4GEMMAccuracy::test_metal_u4_gemm_vs_reference -v --tb=short
      ```

      Fix the Metal kernel OR the Python reference to match exact math.
    priority: P0
    dependencies: []

  - name: fix-u4-nibble-extraction-order
    prompt: |
      Fix INT4 nibble extraction order in marlin_gemm_fused_u4 kernel.

      **Likely Bug**: The order in which we extract nibbles from packed uint32 may not match
      the packing order in the Python reference.

      **Packing Convention** (Python test, verify in test_accuracy.py):
      ```python
      # Pack 8 INT4 values into one uint32
      packed = (w[0] & 0xF) | ((w[1] & 0xF) << 4) | ((w[2] & 0xF) << 8) | ...
      # OR column-major packing for GEMM
      ```

      **Metal Extraction** (in kernel, verify in marlin_gemm.metal):
      ```metal
      // Extract nibble i from packed uint32
      uint nibble = (packed >> (4 * i)) & 0xF;
      ```

      **Check**:
      1. Find the INT4 packing code in `tests/test_accuracy.py` (search "def pack_" or "uint32")
      2. Find the extraction code in `src/marlin_gemm.metal` (search "& 0xF" near u4 functions)
      3. Verify same convention: either both row-major or both column-major
      4. Check for off-by-one: nibble index 0 = first column or last?

      **Test Case**:
      Write a minimal test:
      ```python
      # Pack known values [1, 2, 3, 4, 5, 6, 7, 8]
      # Unpack with Metal kernel
      # Verify output matches [1, 2, 3, 4, 5, 6, 7, 8]
      ```

      Fix either the packing (Python) or extraction (Metal) to match.
    priority: P0
    dependencies:
      - debug-u4-dequant-reference

  - name: fix-u4-scale-zero-indexing
    prompt: |
      Fix scale/zero-point indexing for INT4 group quantization.

      **Group Quantization**: Every `group_size` weights share ONE scale and ONE zero-point.
      If K=1024 and group_size=128, there are K/group_size = 8 groups per column.

      **Indexing Bug Pattern**:
      ```
      # Correct: group index is k_idx / group_size
      group_idx = k / group_size;
      scale_idx = group_idx * N + n;  // [num_groups, N] shaped

      # Bug: off-by-one or transposed
      group_idx = k / group_size;
      scale_idx = n * num_groups + group_idx;  // WRONG shape assumption
      ```

      **Investigation**:
      1. Read Metal kernel `marlin_gemm_fused_u4` - find scale/zero indexing
      2. Read test `TestU4GEMMAccuracy` - find how scales/zeros arrays are created
      3. Verify array shapes match: Python creates [num_groups, N], Metal indexes same way

      **Shapes to verify**:
      - scales: [K // group_size, N] in row-major
      - zeros: [K // group_size, N] in row-major  
      - Metal index: `scales[group_idx * N + col]`

      Fix any mismatch in indexing conventions.
    priority: P0
    dependencies:
      - debug-u4-dequant-reference

  - name: add-u4-debug-print
    prompt: |
      Add debug output to isolate exact location of U4 GEMM error.

      **Goal**: For a small test case (M=1, K=128, N=128), print intermediate values from
      both Python reference and Metal kernel to find where they diverge.

      **Steps**:
      1. In `tests/test_accuracy.py`, add a debug test method:
         ```python
         def test_u4_debug_single_output(self):
             M, K, N = 1, 128, 128
             group_size = 32
             # ... setup weights, scales, zeros ...
             
             # Print first few unpacked Python values
             print(f"Python unpacked B[0:4, 0]: {dequant_ref[0:4, 0]}")
             
             # Run Metal kernel
             result = run_u4_kernel(...)
             
             # Compare element [0, 0]
             print(f"Python C[0,0]: {ref_result[0,0]}")
             print(f"Metal  C[0,0]: {metal_result[0,0]}")
             print(f"Diff: {abs(ref_result[0,0] - metal_result[0,0])}")
         ```

      2. If possible, add a Metal shader that outputs B_dequant instead of C:
         - Create `marlin_debug_u4_dequant` kernel that just dequantizes and stores
         - Compare dequantized weights directly

      Run and analyze divergence point. Document findings.
    priority: P1
    dependencies:
      - debug-u4-dequant-reference

  # ==========================================================================
  # P1: DEPENDENT TESTS (fixed by above)
  # ==========================================================================

  - name: verify-marlin-linear-after-u4-fix
    prompt: |
      Verify MarlinLinear test passes after U4 GEMM fix.

      **Test**: `tests/test_layers.py::TestMarlinLinear::test_from_linear`

      **Dependency**: This test uses MarlinLinear which internally calls the U4 GEMM kernel.
      Once the U4 accuracy is fixed, this should pass automatically.

      **Verification**:
      ```bash
      cd metal_marlin && PYTHONPATH=. uv run pytest tests/test_layers.py::TestMarlinLinear::test_from_linear -v --tb=short
      ```

      If still failing after U4 fix:
      1. Check if MarlinLinear has its own quantization path
      2. Verify weight packing matches test expectations
      3. Check if it uses FP4 vs U4 kernel
    priority: P1
    dependencies:
      - fix-u4-nibble-extraction-order
      - fix-u4-scale-zero-indexing

  - name: verify-onnx-quantized-after-fixes
    prompt: |
      Verify ONNX quantized test passes after kernel fixes.

      **Test**: `tests/test_onnx.py::TestMatmulQuantized::test_quantized_vs_fp16_closeness`

      **Current Error**: Quantized ONNX matmul produces different results than FP16 reference.

      **Verification**:
      ```bash
      cd metal_marlin && PYTHONPATH=. uv run pytest tests/test_onnx.py::TestMatmulQuantized::test_quantized_vs_fp16_closeness -v --tb=short
      ```

      **If still failing**:
      1. Check which quantization format ONNX executor uses (FP4, U4, INT8)
      2. Read `metal_marlin/onnx_executor.py` to find the kernel dispatch
      3. Ensure tolerance is appropriate for quantized inference

      The ONNX test may need tolerance adjustment - quantized models are NOT expected
      to match FP16 exactly, just be "close enough" for practical use.
    priority: P1
    dependencies:
      - fix-metal-shader-mlx-compat

  # ==========================================================================
  # P2: STRIPE PARTITION SPECIFIC ISSUES
  # ==========================================================================

  - name: debug-stripe-k-parallel-atomics
    prompt: |
      Debug K-parallel atomic reduction in stripe partitioned kernel.

      **Background**: The striped kernel splits K-dimension work across threadgroups.
      Each threadgroup computes a partial sum, then atomic reduction combines them.

      **Failing Tests**:
      - test_k_parallel_reduction_large_k
      - test_k_parallel_deterministic[2,4,8]
      - test_k_parallel_zero_input

      **Potential Issues**:
      1. Atomic contention causing incorrect reductions
      2. Lock-based synchronization bugs (two-phase commit)
      3. Float atomics not available on Metal - using lock + non-atomic add

      **Investigation** (after shader compiles):
      1. Read `src/marlin_gemm.metal` lines 1185-1500 (striped kernel)
      2. Find the reduction logic and atomic lock acquire/release
      3. Check `marlin_zero_reduction` kernel for initialization
      4. Trace the data flow: partial_sums -> reduction_buf -> final_C

      **Test Command** (after fix-metal-shader-mlx-compat):
      ```bash
      cd metal_marlin && PYTHONPATH=. uv run pytest tests/test_stripe_partition.py::TestKParallelReduction -v --tb=short
      ```
    priority: P2
    dependencies:
      - fix-metal-shader-mlx-compat
      - validate-shader-syntax-standalone

  - name: debug-stripe-vs-2d-mismatch
    prompt: |
      Debug striped kernel vs 2D kernel numerical mismatch.

      **Failing Tests**:
      - test_striped_matches_2d[various dimensions]
      - test_striped_matches_reference[1,2,4]

      **Expected**: Striped kernel should produce BIT-IDENTICAL results to 2D kernel
      for the same inputs (deterministic reduction order).

      **Investigation**:
      1. For K-parallel=1 (no reduction), results should match exactly
      2. For K-parallel>1, check reduction accumulation order
      3. FP16 addition is NOT associative: (a+b)+c != a+(b+c) in floating point

      **Debug Strategy**:
      1. Add test case with K-parallel=1, compare striped vs 2D
      2. If K=1 matches, issue is in reduction phase
      3. If K=1 differs, issue is in tile iteration order

      **Test** (after compilation fix):
      ```bash
      cd metal_marlin && PYTHONPATH=. uv run pytest "tests/test_stripe_partition.py::TestStripedVs2D::test_striped_matches_2d[128-4096-4096-1]" -v --tb=short
      ```
    priority: P2
    dependencies:
      - fix-metal-shader-mlx-compat

  # ==========================================================================
  # P2: EDGE CASES
  # ==========================================================================

  - name: fix-stripe-edge-cases
    prompt: |
      Fix stripe partition edge cases for various group sizes and dimensions.

      **Failing Tests**:
      - test_different_group_sizes[32,64,128,256]
      - test_non_tile_aligned_dims[various]
      - test_excess_threadgroups
      - test_various_threadgroup_counts[1,5,10,40,80]

      **Edge Case Categories**:
      1. **Group sizes**: group_size=32 needs group_idx = k / 32, verify scale indexing
      2. **Non-aligned dims**: M=30, K=100, N=256 - partial tiles at boundaries
      3. **Threadgroup counts**: More threadgroups than tiles -> some should early-exit

      **Investigation**:
      1. Read striped kernel's tile assignment logic: `tile_idx = tgid.x`, bounds check
      2. Verify partial tile handling: when M < TILE_M or N < TILE_N
      3. Check early exit: `if (tile_idx >= total_tiles) return;`

      **Validation** (after main stripe fix):
      ```bash
      cd metal_marlin && PYTHONPATH=. uv run pytest tests/test_stripe_partition.py::TestStripedEdgeCases -v --tb=short
      ```
    priority: P2
    dependencies:
      - debug-stripe-k-parallel-atomics
      - debug-stripe-vs-2d-mismatch

  # ==========================================================================
  # P3: FINAL VALIDATION
  # ==========================================================================

  - name: run-full-test-suite-validation
    prompt: |
      Run full test suite to verify all 48 failures are resolved.

      **Expected Result**: 0 failures (was 48)

      **Commands**:
      ```bash
      cd metal_marlin

      # Quick check - accuracy and stripe (main failures)
      PYTHONPATH=. uv run pytest tests/test_accuracy.py tests/test_stripe_partition.py -v --tb=no 2>&1 | tail -50

      # Full suite
      PYTHONPATH=. uv run pytest tests/ -v --tb=no 2>&1 | tail -60
      ```

      **Success Criteria**:
      - All TestU4GEMMAccuracy tests pass (was 13 failed)
      - All TestStriped* tests pass (was 33 failed)
      - TestMarlinLinear::test_from_linear passes
      - TestMatmulQuantized::test_quantized_vs_fp16_closeness passes

      If any failures remain, document them for follow-up task creation.
    priority: P3
    dependencies:
      - verify-marlin-linear-after-u4-fix
      - verify-onnx-quantized-after-fixes
      - fix-stripe-edge-cases
